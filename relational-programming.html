<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-10-30 Wed 13:43 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Relational Programming</title>
<meta name="author" content="Roi Martin" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="css/style.css" />
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="index.html"> UP </a>
 |
 <a accesskey="H" href="index.html"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">Relational Programming</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org70c12a3">Introduction</a></li>
<li><a href="#orgdf34656">What is relational programming?</a></li>
<li><a href="#orgc5fabc4">μKanren</a></li>
<li><a href="#org2d9cd94">Dissecting μKanren</a>
<ul>
<li><a href="#org3a26d54">Variables</a></li>
<li><a href="#orgc024530">Substitutions</a></li>
<li><a href="#org79881bd">Goals</a></li>
<li><a href="#orgd01b859">Unification</a></li>
<li><a href="#org7e2976c">The <code>mplus</code> and <code>bind</code> operators</a></li>
</ul>
</li>
<li><a href="#org7205c99">μKanren in practice</a></li>
<li><a href="#org538db23">Related books</a></li>
</ul>
</div>
</div>

<div id="outline-container-org70c12a3" class="outline-2">
<h2 id="org70c12a3">Introduction</h2>
<div class="outline-text-2" id="text-org70c12a3">
<p>
I'm at the very beginning of learning about logic, relational
programming, miniKanren, Prolog, etc.  This page contains my personal
notes as well as links to papers and talks I found interesting.  At
the end of the page there is a list of related books for those that
want to dig deeper.
</p>

<p>
If you want to subscribe to this page, use this <a href="https://github.com/jroimartin/wip.jroi.dev/commits/main/relational-programming.html.atom">RSS feed</a>.
</p>
</div>
</div>

<div id="outline-container-orgdf34656" class="outline-2">
<h2 id="orgdf34656">What is relational programming?</h2>
<div class="outline-text-2" id="text-orgdf34656">
<p>
According to Wikipedia in relation to <a href="https://en.wikipedia.org/wiki/Logic_programming">logic programming</a>:
</p>

<blockquote>
<p>
The term relational programming has been used to cover a variety of
programming languages that treat functions as a special case of
relations.
</p>
</blockquote>

<p>
William E. Byrd provides a great introduction to relational
programming during his talk "<a href="https://youtu.be/AdKXXN5-ApQ">A New Relational Language</a>" at the Houston
FPUG (Functional Programming Users Group).  I tried to summarize it
bellow these lines.
</p>

<p>
In functional programming, given the following expression in Lisp
syntax:
</p>

<pre class="example" id="org84d0ccf">
(+ 3 4) =&gt; 7
</pre>

<p>
We say that <code>+</code> is a function that takes the numbers <code>3</code> and <code>4</code> and
returns their sum, which is <code>7</code>.
</p>

<p>
In other words, there is the notion of:
</p>

<ul class="org-ul">
<li>Function (<code>+</code>)</li>
<li>Inputs (<code>3</code> and <code>4</code>)</li>
<li>Output (<code>7</code>)</li>
</ul>

<p>
Meanwhile, in relational programming, this is expressed in terms of
relations.  Our previous example becomes the following relation:
</p>

<pre class="example" id="org54ca9b6">
(+o 3 4 7)
</pre>

<p>
Which is a 4-place relation where functional programming's dichotomy
between inputs and outputs is gone.  Note that <code>+o</code> in relational
programming is equivalent to <code>+</code> in functional programming.
</p>

<p>
Relations are very flexible because, in addition to the notion of a
relation, we are going to think of in terms of algebra and algebraic
reasoning.  So, we can replace any position in a relation with a
variable.  Then, we can query the system for possible values of those
variables.
</p>

<p>
For instance,
</p>

<pre class="example" id="org42262fb">
(+o 3 4 Z) =&gt; Z = 7
</pre>

<p>
or,
</p>

<pre class="example" id="orgb310147">
(+o 3 Y 7) =&gt; Y = 4
</pre>

<p>
or,
</p>

<pre class="example" id="org3de5e56">
(+o X Y 7) =&gt; X = 0; Y = 7
              X = 1; Y = 6
	      ...
</pre>

<p>
In short, relational programming removes the idea of input vs
output.
</p>
</div>
</div>

<div id="outline-container-orgc5fabc4" class="outline-2">
<h2 id="orgc5fabc4">μKanren</h2>
<div class="outline-text-2" id="text-orgc5fabc4">
<p>
μKanren is a minimalist language in the miniKanren family of
relational programming languages.
</p>

<p>
The miniKanren family of languages is detailed in the thesis
"<a href="https://raw.githubusercontent.com/webyrd/dissertation-single-spaced/master/thesis.pdf">Relational Programming in miniKanren: Techniques, Applications, and
Implementations</a>" by William E. Byrd.
</p>

<p>
What follows is the μKanren implementation exposed on the paper
"<a href="http://webyrd.net/scheme-2013/papers/HemannMuKanren2013.pdf">μKanren: A Minimal Functional Core for Relational Programming</a>" by
Jason Hemann and Daniel P. Friedman.  The code has been commented with
the relevant parts of the paper and is available <a href="relational-programming/ukanren.ss">here</a>.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span class="linenr"> 1: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">Variables are represented as vectors that hold their variable</span>
<span class="linenr"> 2: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">index.  Variable equality is determined by coincidence of indices</span>
<span class="linenr"> 3: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">in vectors.</span>
<span class="linenr"> 4: </span>(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">var</span> c) (vector c))
<span class="linenr"> 5: </span>(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">var?</span> x) (vector? x))
<span class="linenr"> 6: </span>(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">var=?</span> x1 x2) (= (vector-ref x1 0) (vector-ref x2 0)))
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">The walk operator searches for a variable's value in the</span>
<span class="linenr"> 9: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">substitution.  When a non-variable term is walked, the term itself</span>
<span class="linenr">10: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">is returned.</span>
<span class="linenr">11: </span>(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">walk</span> u s)
<span class="linenr">12: </span>  (<span style="color: #a020f0;">let</span> ((pr (<span style="color: #a020f0;">and</span> (var? u) (assp (<span style="color: #a020f0;">lambda</span> (v) (var=? u v)) s))))
<span class="linenr">13: </span>    (<span style="color: #a020f0;">if</span> pr (walk (cdr pr) s) u)))
<span class="linenr">14: </span>
<span class="linenr">15: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">The ext-s operator extends the substitution with a new binding.</span>
<span class="linenr">16: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">When extending the substitution, the first argument is always a</span>
<span class="linenr">17: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">variable and the second is an arbitrary term.</span>
<span class="linenr">18: </span>(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">ext-s</span> x v s) `((,x . ,v) . ,s))
<span class="linenr">19: </span>
<span class="linenr">20: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">The &#8801; goal constructor takes two terms as arguments and returns a</span>
<span class="linenr">21: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">goal that succeeds if those two terms unify in the received state.</span>
<span class="linenr">22: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">If those two terms fail to unify in that state, the empty stream is</span>
<span class="linenr">23: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">instead returned.</span>
<span class="linenr">24: </span>(<span style="color: #a020f0;">define</span> (&#8801; u v)
<span class="linenr">25: </span>  (<span style="color: #a020f0;">lambda</span> (s/c)
<span class="linenr">26: </span>    (<span style="color: #a020f0;">let</span> ((s (unify u v (car s/c))))
<span class="linenr">27: </span>      (<span style="color: #a020f0;">if</span> s (unit `(,s . ,(cdr s/c))) mzero))))
<span class="linenr">28: </span>
<span class="linenr">29: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">unit lifts the state into a stream whose only element is that</span>
<span class="linenr">30: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">state.</span>
<span class="linenr">31: </span>(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">unit</span> s/c) (cons s/c mzero))
<span class="linenr">32: </span>
<span class="linenr">33: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">mzero is the empty stream.</span>
<span class="linenr">34: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">mzero</span> '())
<span class="linenr">35: </span>
<span class="linenr">36: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">Terms of the language are defined by the unify operator.  Here,</span>
<span class="linenr">37: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">terms of the language consist of variables, objects deemed</span>
<span class="linenr">38: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">identical under eqv?, and pairs of the foregoing.  To unify two</span>
<span class="linenr">39: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">terms in a substitution, both are walked in that substitution.  If</span>
<span class="linenr">40: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">the two terms walk to the same variable, the original substitution</span>
<span class="linenr">41: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">is returned unchanged.  When one of the two terms walks to a</span>
<span class="linenr">42: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">variable, the substitution is extended, bindings the variable to</span>
<span class="linenr">43: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">which that term walks with the value of which the other term walks.</span>
<span class="linenr">44: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">If both terms walk to pairs, the cars and then cdrs are unifed</span>
<span class="linenr">45: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">recursively, succeeding if unification succeeds in the one and then</span>
<span class="linenr">46: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">the other.  Finally, non-variable, non-pair terms unify if they are</span>
<span class="linenr">47: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">identical under eqv?, and unification fails otherwise.</span>
<span class="linenr">48: </span>(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">unify</span> u v s)
<span class="linenr">49: </span>  (<span style="color: #a020f0;">let</span> ((u (walk u s)) (v (walk v s)))
<span class="linenr">50: </span>    (<span style="color: #a020f0;">cond</span>
<span class="linenr">51: </span>     ((<span style="color: #a020f0;">and</span> (var? u) (var? v) (var=? u v)) s)
<span class="linenr">52: </span>     ((var? u) (ext-s u v s))
<span class="linenr">53: </span>     ((var? v) (ext-s v u s))
<span class="linenr">54: </span>     ((<span style="color: #a020f0;">and</span> (pair? u) (pair? v))
<span class="linenr">55: </span>      (<span style="color: #a020f0;">let</span> ((s (unify (car u) (car v) s)))
<span class="linenr">56: </span>        (<span style="color: #a020f0;">and</span> s (unify (cdr u) (cdr v) s))))
<span class="linenr">57: </span>     (<span style="color: #a020f0;">else</span> (<span style="color: #a020f0;">and</span> (eqv? u v) s)))))
<span class="linenr">58: </span>
<span class="linenr">59: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">The call/fresh goal constructor takes a unary function f whose body</span>
<span class="linenr">60: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">is a goal, and itself returns a goal.  This returned goal, when</span>
<span class="linenr">61: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">provided a state s/c, binds the formal parameter of f to a new</span>
<span class="linenr">62: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">logic variable, and passes a state, with the substitution it</span>
<span class="linenr">63: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">originally received and a newly incremented fresh-variable counter,</span>
<span class="linenr">64: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">c, to the goal that is the body of f.</span>
<span class="linenr">65: </span>(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">call/fresh</span> f)
<span class="linenr">66: </span>  (<span style="color: #a020f0;">lambda</span> (s/c)
<span class="linenr">67: </span>    (<span style="color: #a020f0;">let</span> ((c (cdr s/c)))
<span class="linenr">68: </span>      ((f (var c)) `(,(car s/c) . ,(+ c 1))))))
<span class="linenr">69: </span>
<span class="linenr">70: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">The disj goal constructor takes two goals as arguments and returns</span>
<span class="linenr">71: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">a goal that succeeds if either of the two subgoals succeed.</span>
<span class="linenr">72: </span>(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">disj</span> g1 g2) (<span style="color: #a020f0;">lambda</span> (s/c) (mplus (g1 s/c) (g2 s/c))))
<span class="linenr">73: </span>
<span class="linenr">74: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">The conj goal constructor similarly takes two goals as arguments</span>
<span class="linenr">75: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">and returns a goal that succeeds if both goals succeed for that</span>
<span class="linenr">76: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">state.</span>
<span class="linenr">77: </span>(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">conj</span> g1 g2) (<span style="color: #a020f0;">lambda</span> (s/c) (bind (g1 s/c) g2)))
<span class="linenr">78: </span>
<span class="linenr">79: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">The search strategy of &#956;Kanren is encoded through the mplus and</span>
<span class="linenr">80: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">bind operators.</span>
<span class="linenr">81: </span>
<span class="linenr">82: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">The mplus operator is responsible for merging streams.</span>
<span class="linenr">83: </span>(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">mplus</span> $1 $2)
<span class="linenr">84: </span>  (<span style="color: #a020f0;">cond</span>
<span class="linenr">85: </span>   ((null? $1) $2)
<span class="linenr">86: </span>   ((procedure? $1) (<span style="color: #a020f0;">lambda</span> () (mplus $2 ($1))))
<span class="linenr">87: </span>   (<span style="color: #a020f0;">else</span> (cons (car $1) (mplus (cdr $1) $2)))))
<span class="linenr">88: </span>
<span class="linenr">89: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">bind invokes the goal g on each element of the stream $.  If the</span>
<span class="linenr">90: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">stream is empty or becomes exhausted mzero, the empty stream, is</span>
<span class="linenr">91: </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">returned.</span>
<span class="linenr">92: </span>(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">bind</span> $ g)
<span class="linenr">93: </span>  (<span style="color: #a020f0;">cond</span>
<span class="linenr">94: </span>   ((null? $) mzero)
<span class="linenr">95: </span>   ((procedure? $) (<span style="color: #a020f0;">lambda</span> () (bind ($) g)))
<span class="linenr">96: </span>   (<span style="color: #a020f0;">else</span> (mplus (g (car $)) (bind (cdr $) g)))))
</pre>
</div>

<p>
μKanren was also shown in the talk "<a href="https://youtu.be/0FwIwewHC3o">Implementing a microKanren</a>" that
Jason Hemann and Daniel P. Friedman gave at Code Mesh 2016.
</p>
</div>
</div>

<div id="outline-container-org2d9cd94" class="outline-2">
<h2 id="org2d9cd94">Dissecting μKanren</h2>
<div class="outline-text-2" id="text-org2d9cd94">
<p>
This μKanren implementation weights 39 lines of code.  Being so short
makes easier to experiment with it.  However, it also hides lots of
details.  In this section I try to analyze every single bit of it to
get a better understanding.
</p>
</div>

<div id="outline-container-org3a26d54" class="outline-3">
<h3 id="org3a26d54">Variables</h3>
<div class="outline-text-3" id="text-org3a26d54">
<p>
Variables are represented as vectors:
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span class="linenr">1: </span>(load <span style="color: #8b2252;">"relational-programming/ukanren.ss"</span>)
<span class="linenr">2: </span>(var 0)
</pre>
</div>

<pre class="example">
#(0)
</pre>


<p>
The 0-th index of the vector is the variable index.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span class="linenr">1: </span>(load <span style="color: #8b2252;">"relational-programming/ukanren.ss"</span>)
<span class="linenr">2: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">x</span> (var 0))
<span class="linenr">3: </span>(vector-ref x 0)
</pre>
</div>

<pre class="example">
0
</pre>


<p>
Two variables are equal if their indices are equal.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span class="linenr">1: </span>(load <span style="color: #8b2252;">"relational-programming/ukanren.ss"</span>)
<span class="linenr">2: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">x</span> (var 0))
<span class="linenr">3: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">y</span> (var 0))
<span class="linenr">4: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">z</span> (var 1))
<span class="linenr">5: </span>(printf <span style="color: #8b2252;">"x == y =&gt; ~a == ~a =&gt; ~a\n"</span> x y (var=? x y))
<span class="linenr">6: </span>(printf <span style="color: #8b2252;">"x == z =&gt; ~a == ~a =&gt; ~a\n"</span> x z (var=? x z))
</pre>
</div>

<pre class="example">
x == y =&gt; #(0) == #(0) =&gt; #t
x == z =&gt; #(0) == #(1) =&gt; #f
</pre>
</div>
</div>

<div id="outline-container-orgc024530" class="outline-3">
<h3 id="orgc024530">Substitutions</h3>
<div class="outline-text-3" id="text-orgc024530">
<p>
A substitution is an association list that binds variables to concrete
values or to other variables.  A substitution can be extended using
the <code>ext-s</code> operator.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span class="linenr">1: </span>(load <span style="color: #8b2252;">"relational-programming/ukanren.ss"</span>)
<span class="linenr">2: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">s</span> '())
<span class="linenr">3: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">s</span> (ext-s (var 0) 'arbitrary-term s))
<span class="linenr">4: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">s</span> (ext-s (var 1) (var 0) s))
<span class="linenr">5: </span>s
</pre>
</div>

<pre class="example">
((#(1) . #(0)) (#(0) . arbitrary-term))
</pre>


<p>
The <code>walk</code> operator searches for a variable's value in the
substitution recursively.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span class="linenr">1: </span>(load <span style="color: #8b2252;">"relational-programming/ukanren.ss"</span>)
<span class="linenr">2: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">s</span> '((#(1) . #(0)) (#(0) . arbitrary-term)))
<span class="linenr">3: </span>(walk (var 1) s)
</pre>
</div>

<pre class="example">
arbitrary-term
</pre>


<p>
When a variable is not bound, the variable itself is returned.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span class="linenr">1: </span>(load <span style="color: #8b2252;">"relational-programming/ukanren.ss"</span>)
<span class="linenr">2: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">s</span> '((#(1) . #(0))))
<span class="linenr">3: </span>(walk (var 1) s)
</pre>
</div>

<pre class="example">
#(0)
</pre>
</div>
</div>

<div id="outline-container-org79881bd" class="outline-3">
<h3 id="org79881bd">Goals</h3>
<div class="outline-text-3" id="text-org79881bd">
<p>
A goal is represented as a function that takes a state a returns a
stream.  A state is a pair of a substitution and a non-negative
integer representing a fresh variable counter.  A stream is a sequence
of states.
</p>

<p>
μKanren provides the following goal constructors: <code>≡</code>, <code>disj</code> and
<code>conj</code>.
</p>

<p>
The ≡ goal constructor takes two terms as arguments and returns a goal
that succeeds if those two terms unify in the received state.  If
those two terms fail to unify in that state, the empty stream is
instead returned.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span class="linenr">1: </span>(load <span style="color: #8b2252;">"relational-programming/ukanren.ss"</span>)
<span class="linenr">2: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">s/c</span> '(() . 0))
<span class="linenr">3: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">g</span> (&#8801; (var 0) 5))
<span class="linenr">4: </span>(g s/c)
</pre>
</div>

<pre class="example">
((((#(0) . 5)) . 0))
</pre>


<p>
Note that the goal does not increment the fresh variable counter.
That is why the <code>call/fresh</code> goal constructor exists.
</p>

<p>
The <code>call/fresh</code> goal constructor takes a unary function <code>f</code> whose
body is a goal, and itself returns a goal.  This returned goal, when
provided a state <code>s/c</code>, binds the formal parameter of <code>f</code> to a new
logic variable, and passes a state, with the substitution it
originally received and a newly incremented fresh-variable counter to
the goal that is the body of <code>f</code>.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span class="linenr">1: </span>(load <span style="color: #8b2252;">"relational-programming/ukanren.ss"</span>)
<span class="linenr">2: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">s/c</span> '(() . 0))
<span class="linenr">3: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">f</span> (<span style="color: #a020f0;">lambda</span> (q) (&#8801; q 5)))
<span class="linenr">4: </span>((call/fresh f) s/c)
</pre>
</div>

<pre class="example">
((((#(0) . 5)) . 1))
</pre>


<p>
If the two terms of <code>≡</code> fail to unify, the empty stream should be
returned.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span class="linenr">1: </span>(load <span style="color: #8b2252;">"relational-programming/ukanren.ss"</span>)
<span class="linenr">2: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">s/c</span> '(() . 0))
<span class="linenr">3: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">f</span> (<span style="color: #a020f0;">lambda</span> (q) (&#8801; 3 5)))
<span class="linenr">4: </span>((call/fresh f) s/c)
</pre>
</div>

<pre class="example">
()
</pre>


<p>
The unification of <code>3</code> and <code>5</code> fails because these terms are not
identical.  We can also verify that the unification of <code>5</code> and
<code>5</code>&#x2014;or <code>q</code> and <code>q</code> in general&#x2014;succeeds but do not extend the
stream.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span class="linenr">1: </span>(load <span style="color: #8b2252;">"relational-programming/ukanren.ss"</span>)
<span class="linenr">2: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">s/c</span> '(() . 0))
<span class="linenr">3: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">f</span> (<span style="color: #a020f0;">lambda</span> (q) (&#8801; 5 5)))
<span class="linenr">4: </span>((call/fresh f) s/c)
</pre>
</div>

<pre class="example">
((() . 1))
</pre>


<div class="org-src-container">
<pre class="src src-scheme"><span class="linenr">1: </span>(load <span style="color: #8b2252;">"relational-programming/ukanren.ss"</span>)
<span class="linenr">2: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">s/c</span> '(() . 0))
<span class="linenr">3: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">f</span> (<span style="color: #a020f0;">lambda</span> (q) (&#8801; q q)))
<span class="linenr">4: </span>((call/fresh f) s/c)
</pre>
</div>

<pre class="example">
((() . 1))
</pre>


<p>
The <code>disj</code> goal constructor takes two goals as arguments and returns a
goal that succeeds if either of the two subgoals succeed.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span class="linenr">1: </span>(load <span style="color: #8b2252;">"relational-programming/ukanren.ss"</span>)
<span class="linenr">2: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">s/c</span> '(() . 0))
<span class="linenr">3: </span>((disj
<span class="linenr">4: </span>  (call/fresh (<span style="color: #a020f0;">lambda</span> (q) (&#8801; q 3)))
<span class="linenr">5: </span>  (call/fresh (<span style="color: #a020f0;">lambda</span> (q) (&#8801; q 5)))) s/c)
</pre>
</div>

<pre class="example">
((((#(0) . 3)) . 1) (((#(0) . 5)) . 1))
</pre>


<p>
The <code>conj</code> goal constructor similarly takes two goals as arguments and
returns a goal that succeeds if both goals succeed for that state.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span class="linenr">1: </span>(load <span style="color: #8b2252;">"relational-programming/ukanren.ss"</span>)
<span class="linenr">2: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">s/c</span> '(() . 0))
<span class="linenr">3: </span>((conj
<span class="linenr">4: </span>  (call/fresh (<span style="color: #a020f0;">lambda</span> (q) (&#8801; q 3)))
<span class="linenr">5: </span>  (call/fresh (<span style="color: #a020f0;">lambda</span> (q) (&#8801; q 5)))) s/c)
</pre>
</div>

<pre class="example">
((((#(1) . 5) (#(0) . 3)) . 2))
</pre>
</div>
</div>

<div id="outline-container-orgd01b859" class="outline-3">
<h3 id="orgd01b859">Unification</h3>
<div class="outline-text-3" id="text-orgd01b859">
<p>
Unification is determined by the <code>unify</code> operator of the μKanren
implementation.  It is especially interesting that it is <code>unify</code> that
defines the terms of the language.  In this implementation terms of
the language consist of variables, objects deemed identical under
<code>eqv?</code> and pairs of the foregoing.
</p>

<p>
To unify two terms in a substitution, both are walked in that
substitution.  If the two terms walk to the same variable, the
original substitution is returned unchanged.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span class="linenr">1: </span>(load <span style="color: #8b2252;">"relational-programming/ukanren.ss"</span>)
<span class="linenr">2: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">s</span> '((#(0) . 5) (#(1) . #(0)) (#(2) . #(0))))
<span class="linenr">3: </span>(unify (var 1) (var 2) s)
</pre>
</div>

<pre class="example">
((#(0) . 5) (#(1) . #(0)) (#(2) . #(0)))
</pre>


<p>
When one of the two terms walks to a variable, the substitution is
extended, bindings the variable to which that term walks with the
value of which the other term walks.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span class="linenr">1: </span>(load <span style="color: #8b2252;">"relational-programming/ukanren.ss"</span>)
<span class="linenr">2: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">s</span> '((#(0) . 5) (#(2) . #(0))))
<span class="linenr">3: </span>(unify (var 1) (var 2) s)
</pre>
</div>

<pre class="example">
((#(1) . 5) (#(0) . 5) (#(2) . #(0)))
</pre>


<div class="org-src-container">
<pre class="src src-scheme"><span class="linenr">1: </span>(load <span style="color: #8b2252;">"relational-programming/ukanren.ss"</span>)
<span class="linenr">2: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">s</span> '((#(0) . 5) (#(2) . #(0))))
<span class="linenr">3: </span>(unify (var 1) 3 s)
</pre>
</div>

<pre class="example">
((#(1) . 3) (#(0) . 5) (#(2) . #(0)))
</pre>


<p>
If both terms walk to pairs, the cars and then cdrs are unifed
recursively, succeeding if unification succeeds in the one and then
the other.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span class="linenr">1: </span>(load <span style="color: #8b2252;">"relational-programming/ukanren.ss"</span>)
<span class="linenr">2: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">s</span> '())
<span class="linenr">3: </span>(unify `(,(var 0) . ,(var 1)) '(3 . 5) s)
</pre>
</div>

<pre class="example">
((#(1) . 5) (#(0) . 3))
</pre>


<p>
Finally, non-variable, non-pair terms unify if they are identical
under eqv?.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span class="linenr">1: </span>(load <span style="color: #8b2252;">"relational-programming/ukanren.ss"</span>)
<span class="linenr">2: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">s</span> '((#(0) . 5)))
<span class="linenr">3: </span>(unify (var 0) 5 s)
</pre>
</div>

<pre class="example">
((#(0) . 5))
</pre>


<div class="org-src-container">
<pre class="src src-scheme"><span class="linenr">1: </span>(load <span style="color: #8b2252;">"relational-programming/ukanren.ss"</span>)
<span class="linenr">2: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">s</span> '())
<span class="linenr">3: </span>(unify 5 5 s)
</pre>
</div>

<pre class="example">
()
</pre>


<p>
Unification fails otherwise.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span class="linenr">1: </span>(load <span style="color: #8b2252;">"relational-programming/ukanren.ss"</span>)
<span class="linenr">2: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">s</span> '((#(0) . 5)))
<span class="linenr">3: </span>(unify (var 0) 3 s)
</pre>
</div>

<pre class="example">
#f
</pre>


<div class="org-src-container">
<pre class="src src-scheme"><span class="linenr">1: </span>(load <span style="color: #8b2252;">"relational-programming/ukanren.ss"</span>)
<span class="linenr">2: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">s</span> '())
<span class="linenr">3: </span>(unify 5 3 s)
</pre>
</div>

<pre class="example">
#f
</pre>
</div>
</div>

<div id="outline-container-org7e2976c" class="outline-3">
<h3 id="org7e2976c">The <code>mplus</code> and <code>bind</code> operators</h3>
<div class="outline-text-3" id="text-org7e2976c">
<p>
The <code>mplus</code> operator is responsible for merging streams.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span class="linenr">1: </span>(load <span style="color: #8b2252;">"relational-programming/ukanren.ss"</span>)
<span class="linenr">2: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">$1</span> '((((#(0) . 3)) . 1) (((#(0) . 5)) . 1)))
<span class="linenr">3: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">$2</span> '((((#(0) . 7)) . 1)))
<span class="linenr">4: </span>(mplus $1 $2)
</pre>
</div>

<pre class="example">
((((#(0) . 3)) . 1) (((#(0) . 5)) . 1) (((#(0) . 7)) . 1))
</pre>


<p>
The <code>disj</code> constructor is defined in terms of the <code>mplus</code> operator.
It takes two goals---<code>g1</code> and <code>g2</code>&#x2014;and returns the stream that
results from merging <code>(g1 s/c)</code> and <code>(g2 s/c)</code>.
</p>

<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">disj</span> g1 g2) (<span style="color: #a020f0;">lambda</span> (s/c) (mplus (g1 s/c) (g2 s/c))))
</pre>
</div>

<p>
The <code>bind</code> operator invokes a goal on each element on a stream.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span class="linenr">1: </span>(load <span style="color: #8b2252;">"relational-programming/ukanren.ss"</span>)
<span class="linenr">2: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">$</span> '((((#(0) . 3)) . 1) (((#(0) . 5)) . 1)))
<span class="linenr">3: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">g</span> (call/fresh (<span style="color: #a020f0;">lambda</span> (q) (&#8801; q 7))))
<span class="linenr">4: </span>(bind $ g)
</pre>
</div>

<pre class="example">
((((#(1) . 7) (#(0) . 3)) . 2) (((#(1) . 7) (#(0) . 5)) . 2))
</pre>


<p>
The <code>conj</code> constructor is defined in terms of the <code>bind</code> operator.  It
takes two goals---<code>g1</code> and <code>g2</code>&#x2014;and returns the stream that results
from invoking <code>g2</code> on each element of the stream returned by <code>(g1
s/c)</code>.
</p>

<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">conj</span> g1 g2) (<span style="color: #a020f0;">lambda</span> (s/c) (bind (g1 s/c) g2)))
</pre>
</div>

<p>
Both <code>mplus</code> and <code>bind</code> are able to return a stream without computing
the answers it contains.  These are called inmature streams and allow
to represent infinite streams.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span class="linenr"> 1: </span>(load <span style="color: #8b2252;">"relational-programming/ukanren.ss"</span>)
<span class="linenr"> 2: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">empty-state</span> '(() . 0))
<span class="linenr"> 3: </span>(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">fives</span> x)
<span class="linenr"> 4: </span>  (disj (&#8801; x 5) (<span style="color: #a020f0;">lambda</span> (s/c) (<span style="color: #a020f0;">lambda</span> () ((fives x) s/c)))))
<span class="linenr"> 5: </span>(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">sixes</span> x)
<span class="linenr"> 6: </span>  (disj (&#8801; x 6) (<span style="color: #a020f0;">lambda</span> (s/c) (<span style="color: #a020f0;">lambda</span> () ((sixes x) s/c)))))
<span class="linenr"> 7: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">fives-and-sixes</span>
<span class="linenr"> 8: </span>  (call/fresh (<span style="color: #a020f0;">lambda</span> (x) (disj (fives x) (sixes x)))))
<span class="linenr"> 9: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">stream</span> (fives-and-sixes empty-state))
<span class="linenr">10: </span>
<span class="linenr">11: </span>(printf <span style="color: #8b2252;">"~a\n"</span> stream)
<span class="linenr">12: </span>(printf <span style="color: #8b2252;">"~a\n"</span> ((cdr stream)))
<span class="linenr">13: </span>(printf <span style="color: #8b2252;">"~a\n"</span> ((cdr ((cdr stream)))))
<span class="linenr">14: </span>(printf <span style="color: #8b2252;">"~a\n"</span> ((cdr ((cdr ((cdr stream)))))))
</pre>
</div>

<pre class="example">
((((#(0) . 5)) . 1) . #&lt;procedure at ukanren.ss:3505&gt;)
((((#(0) . 6)) . 1) . #&lt;procedure at ukanren.ss:3505&gt;)
((((#(0) . 5)) . 1) . #&lt;procedure at ukanren.ss:3505&gt;)
((((#(0) . 6)) . 1) . #&lt;procedure at ukanren.ss:3505&gt;)
</pre>
</div>
</div>
</div>

<div id="outline-container-org7205c99" class="outline-2">
<h2 id="org7205c99">μKanren in practice</h2>
<div class="outline-text-2" id="text-org7205c99">
<p>
The following is a very simple example of how to use the core
functionality of μKanren:
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span class="linenr">1: </span>(load <span style="color: #8b2252;">"relational-programming/ukanren.ss"</span>)
<span class="linenr">2: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">empty-state</span> '(() . 0))
<span class="linenr">3: </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">a-and-b</span>
<span class="linenr">4: </span>  (conj
<span class="linenr">5: </span>   (call/fresh (<span style="color: #a020f0;">lambda</span> (a) (&#8801; a 7)))
<span class="linenr">6: </span>   (call/fresh (<span style="color: #a020f0;">lambda</span> (b) (disj (&#8801; b 5) (&#8801; b 6))))))
<span class="linenr">7: </span>(a-and-b empty-state)
</pre>
</div>

<pre class="example">
((((#(1) . 5) (#(0) . 7)) . 2) (((#(1) . 6) (#(0) . 7)) . 2))
</pre>
</div>
</div>

<div id="outline-container-org538db23" class="outline-2">
<h2 id="org538db23">Related books</h2>
<div class="outline-text-2" id="text-org538db23">
<ul class="org-ul">
<li>"Introduction to Logic" by Patrick Suppes</li>
<li>"The Little Lisper" by Daniel P. Friedman</li>
<li>"The Little Schemer, Fourth Edition" by Daniel P. Friedman and Matthias Felleisen</li>
<li>"The Reasoned Schemer, Second Edition" by Daniel P. Friedman, William E. Byrd, Oleg Kiselyov and Jason Hemann</li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2024-06-22 Sat 00:00</p>
<p class="author">Author: Roi Martin</p>
<p class="date">Created: 2024-10-30 Wed 13:43</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
